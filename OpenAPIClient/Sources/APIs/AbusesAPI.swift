//
// AbusesAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class AbusesAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://peertube2.cpy.re")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    public enum ApiV1AbusesAbuseIdDeleteError: Error, CustomStringConvertible {
        // block not found
        case code404Error

        public var description: String {
            switch self {
            case .code404Error:
                return "ApiV1AbusesAbuseIdDeleteError: block not found"
            }
        }
    }

    /// Delete an abuse
    /// - DELETE /api/v1/abuses/{abuseId}
    /// - OAuth:
    /// - type: oauth2
    /// - name: OAuth2
    /// - parameter abuseId: (path) Abuse id 
    /// - returns: AnyPublisher<Void, Error> 
    open func apiV1AbusesAbuseIdDelete(abuseId: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/api/v1/abuses/{abuseId}"
                path = path.replacingOccurrences(of: "{abuseId}", with: "\(abuseId)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 404 {
                        return ApiV1AbusesAbuseIdDeleteError.code404Error
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete an abuse message
    /// - DELETE /api/v1/abuses/{abuseId}/messages/{abuseMessageId}
    /// - OAuth:
    /// - type: oauth2
    /// - name: OAuth2
    /// - parameter abuseId: (path) Abuse id 
    /// - parameter abuseMessageId: (path) Abuse message id 
    /// - returns: AnyPublisher<Void, Error> 
    open func apiV1AbusesAbuseIdMessagesAbuseMessageIdDelete(abuseId: Int, abuseMessageId: Int) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/api/v1/abuses/{abuseId}/messages/{abuseMessageId}"
                path = path.replacingOccurrences(of: "{abuseId}", with: "\(abuseId)")
                path = path.replacingOccurrences(of: "{abuseMessageId}", with: "\(abuseMessageId)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// List messages of an abuse
    /// - GET /api/v1/abuses/{abuseId}/messages
    /// - OAuth:
    /// - type: oauth2
    /// - name: OAuth2
    /// - parameter abuseId: (path) Abuse id 
    /// - returns: AnyPublisher<ApiV1AbusesAbuseIdMessagesGet200Response, Error> 
    open func apiV1AbusesAbuseIdMessagesGet(abuseId: Int) -> AnyPublisher<ApiV1AbusesAbuseIdMessagesGet200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/api/v1/abuses/{abuseId}/messages"
                path = path.replacingOccurrences(of: "{abuseId}", with: "\(abuseId)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ApiV1AbusesAbuseIdMessagesGet200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ApiV1AbusesAbuseIdMessagesGet200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ApiV1AbusesAbuseIdMessagesPostError: Error, CustomStringConvertible {
        // incorrect request parameters
        case code400Error

        public var description: String {
            switch self {
            case .code400Error:
                return "ApiV1AbusesAbuseIdMessagesPostError: incorrect request parameters"
            }
        }
    }

    /// Add message to an abuse
    /// - POST /api/v1/abuses/{abuseId}/messages
    /// - OAuth:
    /// - type: oauth2
    /// - name: OAuth2
    /// - parameter abuseId: (path) Abuse id 
    /// - parameter apiV1AbusesAbuseIdMessagesPostRequest: (body)  
    /// - returns: AnyPublisher<Void, Error> 
    open func apiV1AbusesAbuseIdMessagesPost(abuseId: Int, apiV1AbusesAbuseIdMessagesPostRequest: ApiV1AbusesAbuseIdMessagesPostRequest) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/api/v1/abuses/{abuseId}/messages"
                path = path.replacingOccurrences(of: "{abuseId}", with: "\(abuseId)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(apiV1AbusesAbuseIdMessagesPostRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return ApiV1AbusesAbuseIdMessagesPostError.code400Error
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ApiV1AbusesAbuseIdPutError: Error, CustomStringConvertible {
        // abuse not found
        case code404Error

        public var description: String {
            switch self {
            case .code404Error:
                return "ApiV1AbusesAbuseIdPutError: abuse not found"
            }
        }
    }

    /// Update an abuse
    /// - PUT /api/v1/abuses/{abuseId}
    /// - OAuth:
    /// - type: oauth2
    /// - name: OAuth2
    /// - parameter abuseId: (path) Abuse id 
    /// - parameter apiV1AbusesAbuseIdPutRequest: (body)  (optional)
    /// - returns: AnyPublisher<Void, Error> 
    open func apiV1AbusesAbuseIdPut(abuseId: Int, apiV1AbusesAbuseIdPutRequest: ApiV1AbusesAbuseIdPutRequest? = nil) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var path = "/api/v1/abuses/{abuseId}"
                path = path.replacingOccurrences(of: "{abuseId}", with: "\(abuseId)")
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(apiV1AbusesAbuseIdPutRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 404 {
                        return ApiV1AbusesAbuseIdPutError.code404Error
                    }
                    return transportError
                }
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    public enum ApiV1AbusesPostError: Error, CustomStringConvertible {
        // incorrect request parameters
        case code400Error

        public var description: String {
            switch self {
            case .code400Error:
                return "ApiV1AbusesPostError: incorrect request parameters"
            }
        }
    }

    /// Report an abuse
    /// - POST /api/v1/abuses
    /// - OAuth:
    /// - type: oauth2
    /// - name: OAuth2
    /// - parameter apiV1AbusesPostRequest: (body)  
    /// - returns: AnyPublisher<ApiV1AbusesPost200Response, Error> 
    open func apiV1AbusesPost(apiV1AbusesPostRequest: ApiV1AbusesPostRequest) -> AnyPublisher<ApiV1AbusesPost200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/api/v1/abuses"
                let url = baseURL.appendingPathComponent(path)
                let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(apiV1AbusesPostRequest)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ApiV1AbusesPost200Response, Error> in 
            return self.transport.send(request: request)
                .mapError { transportError -> Error in 
                    if transportError.statusCode == 400 {
                        return ApiV1AbusesPostError.code400Error
                    }
                    return transportError
                }
                .tryMap { response in
                    try self.decoder.decode(ApiV1AbusesPost200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter predefinedReason
    ///
    public enum GetAbusesPredefinedReason: String, Codable, CaseIterable {
        case violentorabusive = "violentOrAbusive"
        case hatefulorabusive = "hatefulOrAbusive"
        case spamormisleading = "spamOrMisleading"
        case privacy = "privacy"
        case rights = "rights"
        case serverrules = "serverRules"
        case thumbnails = "thumbnails"
        case captions = "captions"
    }
    ///
    /// Enum for parameter videoIs
    ///
    public enum GetAbusesVideoIs: String, Codable, CaseIterable {
        case deleted = "deleted"
        case blacklisted = "blacklisted"
    }
    ///
    /// Enum for parameter filter
    ///
    public enum GetAbusesFilter: String, Codable, CaseIterable {
        case video = "video"
        case comment = "comment"
        case account = "account"
    }
    ///
    /// Enum for parameter sort
    ///
    public enum GetAbusesSort: String, Codable, CaseIterable {
        case id = "-id"
        case createdat = "-createdAt"
        case state = "-state"
    }

    /// List abuses
    /// - GET /api/v1/abuses
    /// - OAuth:
    /// - type: oauth2
    /// - name: OAuth2
    /// - parameter id: (query) only list the report with this id (optional)
    /// - parameter predefinedReason: (query) predefined reason the listed reports should contain (optional)
    /// - parameter search: (query) plain search that will match with video titles, reporter names and more (optional)
    /// - parameter state: (query)  (optional)
    /// - parameter searchReporter: (query) only list reports of a specific reporter (optional)
    /// - parameter searchReportee: (query) only list reports of a specific reportee (optional)
    /// - parameter searchVideo: (query) only list reports of a specific video (optional)
    /// - parameter searchVideoChannel: (query) only list reports of a specific video channel (optional)
    /// - parameter videoIs: (query) only list deleted or blocklisted videos (optional)
    /// - parameter filter: (query) only list account, comment or video reports (optional)
    /// - parameter start: (query) Offset used to paginate results (optional)
    /// - parameter count: (query) Number of items to return (optional, default to 15)
    /// - parameter sort: (query) Sort abuses by criteria (optional)
    /// - returns: AnyPublisher<GetMyAbuses200Response, Error> 
    open func getAbuses(id: Int? = nil, predefinedReason: [GetAbusesPredefinedReason]? = nil, search: String? = nil, state: AbuseStateSet? = nil, searchReporter: String? = nil, searchReportee: String? = nil, searchVideo: String? = nil, searchVideoChannel: String? = nil, videoIs: GetAbusesVideoIs? = nil, filter: GetAbusesFilter? = nil, start: Int? = nil, count: Int? = nil, sort: GetAbusesSort? = nil) -> AnyPublisher<GetMyAbuses200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/api/v1/abuses"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let id = id { queryItems.append(URLQueryItem(name: "id", value: "\(id)")) } 
                if let predefinedReason = predefinedReason { queryItems.append(URLQueryItem(name: "predefinedReason", value: predefinedReason.map { $0.rawValue }.joined(separator: ","))) } 
                if let search = search { queryItems.append(URLQueryItem(name: "search", value: search)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state.rawValue)) } 
                if let searchReporter = searchReporter { queryItems.append(URLQueryItem(name: "searchReporter", value: searchReporter)) } 
                if let searchReportee = searchReportee { queryItems.append(URLQueryItem(name: "searchReportee", value: searchReportee)) } 
                if let searchVideo = searchVideo { queryItems.append(URLQueryItem(name: "searchVideo", value: searchVideo)) } 
                if let searchVideoChannel = searchVideoChannel { queryItems.append(URLQueryItem(name: "searchVideoChannel", value: searchVideoChannel)) } 
                if let videoIs = videoIs { queryItems.append(URLQueryItem(name: "videoIs", value: videoIs.rawValue)) } 
                if let filter = filter { queryItems.append(URLQueryItem(name: "filter", value: filter.rawValue)) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let count = count { queryItems.append(URLQueryItem(name: "count", value: "\(count)")) } 
                if let sort = sort { queryItems.append(URLQueryItem(name: "sort", value: sort.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetMyAbuses200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetMyAbuses200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sort
    ///
    public enum GetMyAbusesSort: String, Codable, CaseIterable {
        case id = "-id"
        case createdat = "-createdAt"
        case state = "-state"
    }

    /// List my abuses
    /// - GET /api/v1/users/me/abuses
    /// - OAuth:
    /// - type: oauth2
    /// - name: OAuth2
    /// - parameter id: (query) only list the report with this id (optional)
    /// - parameter state: (query)  (optional)
    /// - parameter sort: (query) Sort abuses by criteria (optional)
    /// - parameter start: (query) Offset used to paginate results (optional)
    /// - parameter count: (query) Number of items to return (optional, default to 15)
    /// - returns: AnyPublisher<GetMyAbuses200Response, Error> 
    open func getMyAbuses(id: Int? = nil, state: AbuseStateSet? = nil, sort: GetMyAbusesSort? = nil, start: Int? = nil, count: Int? = nil) -> AnyPublisher<GetMyAbuses200Response, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let path = "/api/v1/users/me/abuses"
                let url = baseURL.appendingPathComponent(path)
                var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let id = id { queryItems.append(URLQueryItem(name: "id", value: "\(id)")) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state.rawValue)) } 
                if let sort = sort { queryItems.append(URLQueryItem(name: "sort", value: sort.rawValue)) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let count = count { queryItems.append(URLQueryItem(name: "count", value: "\(count)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GetMyAbuses200Response, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GetMyAbuses200Response.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
